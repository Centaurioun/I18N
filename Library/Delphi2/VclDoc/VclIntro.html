<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>
<meta http-equiv="content-type" content="text/html; charset=iso-8859-1">
<title>Soluling's VCL Classes: Soluling's VCL Classes</title>
<link rel="StyleSheet" type="text/css" href="pasdoc.css">
</head>
<body bgcolor="#ffffff" text="#000000" link="#0000ff" vlink="#800080" alink="#FF0000">
<h1 class="externalitem">Soluling's VCL Classes</h1>


<p><img src="image_0.png" alt="user_earth" />

<p>Use these classes to implement runtime language switch for your Delphi applications. If you don't want to implement runtime language switch you can still use some of the functions such as plural and gender functions in <a class="normal"  href="NtPattern.html">NtPattern</a>, abbreviated numbers in <a class="normal"  href="NtNumber.html">NtNumber</a>, ordinal numbers in <a class="normal"  href="NtOrdinal.html">NtOrdinal</a>, file dialog functions in <a class="normal"  href="NtDialog.html">NtDialog</a>, database functions in <a class="normal"  href="NtDatabaseUtils.html">NtDatabaseUtils</a>, and form layout checking in <a class="normal"  href="NtChecker.html">NtChecker</a>.

<p>Implementing a runtime language switch is very easy with Soluling. First step is to create resource DLL files. Soluling makes them for you. Once you have at least one resource DLL you can perform runtime language switch.

<p><img src="image_1.png" alt="ExeAndResourceDlls" />

<p>In a simple application you only have to add one line of code. Following sample contains an event that is called after user has clicked LanguageButton on your form.

<p></p>

<pre class="longcode">
<span class="pascal_keyword">procedure</span> TForm1.LanguageButtonClick(Sender: TObject);
<span class="pascal_keyword">begin</span>
  TNtLanguageDialog.Select(<span class="pascal_string">'en'</span>);
<span class="pascal_keyword">end</span>;
</pre>

<p>

<p><a class="normal"  href="NtLanguageDlg.TNtLanguageDialog.html#Select">TNtLanguageDialog.Select</a> shows a language dialog that contains list of available language (e.g. available resource DLLs). User can select a new language. Once selected the function loads the resource DLL matching the selected language and automatically translates all forms that have been created.

<p>If you want to implement your own language selection user interface you can do that very easily. Use <a class="normal"  href="NtBase.TNtBase.html#GetAvailable">TNtBase.GetAvailable</a> function to get available languages. Use the language list it returned to populate your language selection. Write an event handler to response to a language selection. In the event call <a class="normal"  href="NtTranslator.TNtTranslator.html#SetNew">TNtTranslator.SetNew</a> to load a resource DLL matching the selected language and to translate the forms of your application. See <i>Samples\Delphi\VCL\CustomSelect</i> sample to see how to implement your own language selecting user interface.

<p><b>Properties that are set on run time</b>

<p><a class="normal"  href="NtTranslator.TNtTranslator.html">TNtTranslator</a> translates automatically everything that is stored in the form files (DFM). So all components you have added and all the properties you have set on design time get automatically translated. However the class can not automatically translate properties that you have set on run time. To translate them you have to write a code that translates them after you have selected a new language. See the following sample.

<p></p>

<pre class="longcode">
<span class="pascal_keyword">procedure</span> TForm1.UpdateItems;
<span class="pascal_keyword">resourcestring</span>
  SSample = <span class="pascal_string">'This is sample'</span>;
<span class="pascal_keyword">begin</span>
  Label1.Caption := SSample;
<span class="pascal_keyword">end</span>;

<span class="pascal_keyword">procedure</span> TForm1.FormShow(Sender: TObject);
<span class="pascal_keyword">begin</span>
  UpdateItems;
<span class="pascal_keyword">end</span>;

<span class="pascal_keyword">procedure</span> TForm1.LanguageButtonClick(Sender: TObject);
<span class="pascal_keyword">begin</span>
  <span class="pascal_keyword">if</span> TNtLanguageDialog.Select(<span class="pascal_string">'en'</span>) <span class="pascal_keyword">then</span>
    UpdateItems;
<span class="pascal_keyword">end</span>;
</pre>

<p>

<p>The form contains UpdateItems procedure that set a property value. Once you create the form you call the function in order set the property values on run time. Once language have been selected in LanguageButtonClick event the loaded resource DLL is different and the value SSample is not necessary the same as in the application start up. This is why we have to call UpdateItems procedure again in order to translate the property that were set on run time. See <i>Samples\Delphi\VCL\LanguageSwitch</i> sample to see how to translate runtime properties.

<p><b>Original language</b>

<p>Original language is the language you use when you write your application. In most cases this is English but programmers for example in France, Germany and Japan tend to user their own languages. By default a Delphi application does not have any information about the language that has been used on forms and messages. Most applications do not need this information. However it is needed on same cases. <a class="normal"  href="NtBase.html">NtBase</a> unit contains <a class="normal"  href="NtBase.html#DefaultLocale">NtBase.DefaultLocale</a> variable that specifies the original language. If your original language is not English assign the right value in this variable in the initialization code of your application.

<p><b>Initial language</b>

<p>The default locale of a Delphi application depends on the Delphi version. Up to Delphi 2009 the default locale was locale set in the Regional Settings of Control Panel. Starting from Delphi 2010 this no longer the case. The default locale is the language of the operating system itself. If you want to have the old behavior with Delphi 2010 or later use <a class="normal"  href="NtInitialLocale.html">NtInitialLocale</a> unit.

<p><b>Single file deployment</b>

<p>Normally resource DLL files are external files that locate on the sample directory as the application. For example if we have Project1.exe then the German resource DLL would be Project1.de.

<p>One of the great feature of Delphi is the possibility to create single EXE applications that require no DLLs. Using resource DLLs breaks this. Fortunately Soluling's classes provide a solution for this. Soluling contains a tool called AddResource. It is a command line tool that adds a file into an EXE or DLL file as a resource. So the external file is moved inside EXE or DLL and stored in a resource block. When application start it extract data from these resource into external resource DLL that VCL requires.

<p>First you call <a class="normal"  href="NtBase.TNtBase.html#ExtractFiles">TNtBase.ExtractFiles</a> procedure in the initialization block of your main unit. Then you use Soluling to create resource DLL file(s). Finally you use AddResource.exe add the resource DLL into your EXE file. Now you have an EXE file that requires no other files.

<p><b>Extending translator</b>

<p><a class="normal"  href="NtTranslator.TNtTranslator.html">TNtTranslator</a> can perform runtime language switch for all normal properties. It can not translate some binary or defined properties of certain components. These properties are called complex properties. For example TImage contains the image data in a binary format in the Picture.Data property of the form file. To translate this <a class="normal"  href="NtTranslator.TNtTranslator.html">TNtTranslator</a> uses <a class="normal"  href="NtPictureTranslator.TNtPictureTranslator.html">TNtPictureTranslator</a>. Translator extensions are add-on to for <a class="normal"  href="NtTranslator.TNtTranslator.html">TNtTranslator</a>. They perform the translation of complex properties. Soluling contains several extension for <a class="normal"  href="NtPictureTranslator.TNtPictureTranslator.html">picture</a>, <a class="normal"  href="NtBaseTranslator.TNtStringsTranslator.html">string list</a>, <a class="normal"  href="NtTreeViewTranslator.TNtTreeViewTranslator.html">tree views</a> and <a class="normal"  href="NtListViewTranslator.TNtListViewTranslator.html">list view</a>. Some extension are for 3rd party components such as <a class="normal"  href="NtVirtualTreeTranslator.TNtVirtualTreeViewTranslator.html">Virtual tree view</a>. You can easily implement your own extension if needed.

<p><b>Grammatical numbers and genders</b>

<p>Standard VCL contains Format function that is used to combine message pattern with parameters to create composite message string. Format function is very useful but it lacks one important feature: grammatical plurals and genders. In most languages you have to write sentence in a different way depending on the grammatical number and/or gender. To make this possible use <a class="normal"  href="NtPattern.html">NtPattern</a> unit.

<p>See samples in <i>Samples\Delphi\VCL\Patterns</i> directory.

<p><b>Abbreviated numbers</b>

<p>Standard VCL does not contain a function to convert a number into its abbreviated form. For example number 12000 would be &quot;12K&quot; or &quot;12 thousand&quot; or &quot;$12K&quot; when abbreviated in English (United States). Use <a class="normal"  href="NtNumber.html">NtNumber</a> unit to convert numbers into abbreviated form strings.

<p>See <i>Samples\Delphi\VCL\Driving\Number</i> sample.

<p><b>Ordinal numbers</b>

<p>Standard VCL does not contain a function to convert an ordinal number into string. For example ordinal 1 in English would be either &quot;1st&quot; or &quot;first&quot; depending if short or long form is used. Use <a class="normal"  href="NtOrdinal.html">NtOrdinal</a> unit to convert ordinal numbers into strings.

<p>See <i>Samples\Delphi\VCL\Driving\Ordinal</i> sample.

<p><b>Filters in file dialogs</b>

<p>TOpenDialog and TSaveDialog have Filter property that let's you populate the file type combo box of the dialog. The required format of the filter string is quite complex and it may break during the translation. To avoid this use <a class="normal"  href="NtDialog.TNtDialogFilter.html">TNtDialogFilter</a> class to easily create filter string such way that the text in the filter is easy and safe to translate.

<p>See <i>Samples\Delphi\VCL\Driving\FileDialog</i> sample.

<p><b>Form checking</b>

<p>In many cases translations are longer than original strings. Thay my cause some controls in you forms to overlap and some text in the controls to truncate. It may be difficult to manually detect these. This is why you can use <a class="normal"  href="NtChecker.TFormChecker.html">TFormChecker</a> to automatically check you forms once you run your application. The checker will write a report and take screenshots that show each problem you have.

<p>You will get best use of <a class="normal"  href="NtChecker.TFormChecker.html">TFormChecker</a> class if you use automated tests that are run each time you build your software.

<p><a class="normal"  href="NtChecker.TFormChecker.html">TFormChecker</a> can perform runtime checking for most of the controls. However it can not check some controls that have multiple panels and only one of those panels is visislbe at the time. Such controls are from exampel page/tab controls and various expander controls. To check those <a class="normal"  href="NtChecker.TFormChecker.html">TFormChecker</a> uses extensions. They are add-on to for <a class="normal"  href="NtChecker.TFormChecker.html">TFormChecker</a>. They provide helper functions for checking of complex controls. Soluling contains several extension for <a class="normal"  href="NtChecker.TNtTabControlChecker.html">tab control</a>, <a class="normal"  href="NtRaizeChecker.TNtRaizeChecker.html">Raize controls</a>, <a class="normal"  href="NtTmsChecker.TNtTmsChecker.html">TMS controls</a> and <a class="normal"  href="NtDevExpressChecker.TNtDevExpressChecker.html">DevExpress controls</a>. You can easily implement your own extension if needed.

<p><b>Samples</b>

<p><i>Samples\Delphi\VCL</i> directory contains several simple samples that cover different properties of Soluling's VCL classes. Go through to samples to learn how to use the classes.

<p><b>Tutorial</b>

<p>Study first <i>Samples\Delphi\VCL\Driving\Original</i> sample. It is not localized but English only. In fact it can not be localized property because the project has not been internationalized. It contains hard coded string and code that is not world ready.

<p><i>Samples\Delphi\VCL\Driving\Localized</i> contains the same sample application but internationalized and localized to several languages. Compare the code of these two application to see what is the different between world ready and English-only application.

<p>Finally <i>Samples\Delphi\VCL\Driving\Multilingual</i> contains the same applications but now runtime language switch has been enabled. These three applications demonstrate the three different levels of localization:

<p></p>

<ol class="paragraph_spacing">
  <li value="1"><p>Single language application. Not internationalized. Not localized.</p></li>
  <li value="2"><p>World enabled application. Localized.</p></li>
  <li value="3"><p>Runtime language switch enabled application. Localized.</p></li>
</ol>

<p>

<p>When you localize your application your target is at least #2. Depending on your needs and resources you can go further. Soluling's add-on product, Resourcer, helps you to replace hard coded strings with resource strings.

<p><b>Bi-directional languages</b>

<p>It is relatively easy to internationalize for languages that do use left to right reading order such as English, German and Japanese. However things get a lot harder if you want to support languages that use right to left reading order such as Arabic, Hebrew and Persian.

<p>You have to provide &quot;mirrored&quot; user interface. There are two ways to do that. First is to let Soluling mirror each forms. Another is to used VCL' TForm.FlipChildren function to mirror forms on run time. The later is recommended but also requires you to modify your code more. You have to be carefully when to mirror the form. It should be done before the forms gets visible but after you have added any possible runtime controls on the form. <a class="normal"  href="NtTranslator.TNtTranslator.html">TNtTranslator</a> has a built-in support for BiDi languages. It can automatically mirror the forms when needed. See <i>Samples\Delphi\VCL\BiDi\Localized</i> sample to see how to implement localized BiDi-enabled application. See <i>Samples\Delphi\VCL\BiDi\Multilingual</i> sample to see how to imlement runtime language switch and BiDi-enabled application.

<p><b>C++Builder</b>

<p>These classes are compatible to C++Builder compiler. However C++Builder is not officially supported.

<p>Soluling covers most if not all your needs for Delphi internatioalization and localization. Soluling itself has been written in Delphi by Delphi gurus. We know Delphi and we know localization. Soluling provides you the easiest and fastest way to localize your Delphi applications.</body></html>
